/* Generated by Yosys 0.55+115 (git sha1 1d229ae25, clang++ 20.1.8 -fPIC -O3 -flto=thin) */

module tqvp_sohaib_npu(address, data_in, data_write_n, data_read_n, clk, rst_n, uo_out, data_out, data_ready, user_interrupt, ui_in);
  reg \$auto$verilog_backend.cc:2373:dump_module$1  = 0;
  wire \$1 ;
  wire \$10 ;
  wire [15:0] \$11 ;
  wire \$12 ;
  wire \$13 ;
  wire \$14 ;
  wire [15:0] \$15 ;
  wire [15:0] \$16 ;
  wire \$17 ;
  wire \$18 ;
  reg [4:0] \$19 ;
  wire \$2 ;
  reg [14:0] \$20 ;
  reg \$21 ;
  reg [3:0] \$22 ;
  wire [11:0] \$23 ;
  wire \$3 ;
  wire \$4 ;
  wire \$5 ;
  wire \$6 ;
  wire \$7 ;
  wire \$8 ;
  wire \$9 ;
  wire [15:0] a;
  wire [3:0] \a[0] ;
  wire [3:0] \a[1] ;
  wire [3:0] \a[2] ;
  wire [3:0] \a[3] ;
  wire [15:0] acc__payload;
  wire [-1:0] \acc__payload.addr ;
  wire [15:0] \acc__payload.data ;
  wire [15:0] \acc__payload.data[0] ;
  wire acc__valid;
  input [5:0] address;
  wire [5:0] address;
  input clk;
  wire clk;
  wire [15:0] d;
  wire [15:0] \d[0] ;
  input [31:0] data_in;
  wire [31:0] data_in;
  output [31:0] data_out;
  wire [31:0] data_out;
  input [1:0] data_read_n;
  wire [1:0] data_read_n;
  output data_ready;
  wire data_ready;
  input [1:0] data_write_n;
  wire [1:0] data_write_n;
  wire [15:0] init__payload;
  wire [-1:0] \init__payload.addr ;
  wire [15:0] \init__payload.data ;
  wire [15:0] \init__payload.data[0] ;
  wire init__valid;
  reg [3:0] out_zp = 4'h0;
  reg [14:0] qmuls = 15'h0000;
  wire [14:0] \qmuls[0] ;
  wire [-1:0] read__addr;
  wire [15:0] read__data;
  wire [15:0] \read__data[0] ;
  reg relu = 1'h0;
  wire [39:0] req__payload;
  wire [15:0] \req__payload.a ;
  wire [15:0] \req__payload.a[0] ;
  wire [14:0] \req__payload.b ;
  wire [14:0] \req__payload.b[0] ;
  wire [4:0] \req__payload.shamt ;
  wire [4:0] \req__payload.shamt[0] ;
  wire [3:0] \req__payload.zp ;
  wire req__valid;
  wire [3:0] resp__payload;
  wire [3:0] \resp__payload[0] ;
  wire resp__valid;
  input rst_n;
  wire rst_n;
  wire rst = !rst_n;
  reg [4:0] shamts = 5'h00;
  wire [4:0] \shamts[0] ;
  input [7:0] ui_in;
  wire [7:0] ui_in;
  output [7:0] uo_out;
  wire [7:0] uo_out;
  output user_interrupt;
  wire user_interrupt;
  wire [15:0] w;
  wire [3:0] \w[0] ;
  wire [3:0] \w[0][0] ;
  wire [3:0] \w[1] ;
  wire [3:0] \w[1][0] ;
  wire [3:0] \w[2] ;
  wire [3:0] \w[2][0] ;
  wire [3:0] \w[3] ;
  wire [3:0] \w[3][0] ;
  assign \$1  = ! data_write_n;
  assign \$2  = address[2] & \$1 ;
  assign \$3  = data_write_n == 1'h1;
  assign \$4  = address[3] & \$3 ;
  assign \$5  = ! data_write_n;
  assign \$6  = address[4] & \$5 ;
  assign \$7  = data_write_n == 1'h1;
  assign init__valid = address[1] & \$7 ;
  assign \$8  = data_write_n == 2'h2;
  assign acc__valid = address[0] & \$8 ;
  assign \$9  = ! data_read_n;
  assign req__valid = address[1] & \$9 ;
  assign \$10  = relu & read__data[15];
  assign \$11  = \$10  ? 16'h0000 : read__data;
  assign \$12  = data_read_n == 1'h1;
  assign \$13  = address[1] & \$12 ;
  assign \$14  = relu & read__data[15];
  assign \$15  = \$14  ? 16'h0000 : read__data;
  assign \$16  = \$13  ? \$15  : { 12'h000, resp__payload };
  assign \$17  = data_read_n == 1'h1;
  assign \$18  = address[1] & \$17 ;
  assign data_ready = \$18  | resp__valid;
  always @(posedge clk)
    shamts <= \$19 ;
  always @(posedge clk)
    qmuls <= \$20 ;
  always @(posedge clk)
    relu <= \$21 ;
  always @(posedge clk)
    out_zp <= \$22 ;
  \tqvp_sohaib_npu.acc_regs  acc_regs (
    .acc__valid(acc__valid),
    .clk(clk),
    .init__payload(data_in[15:0]),
    .init__valid(init__valid),
    .\port$31$0 (\$23 ),
    .read__data(read__data),
    .rst(rst)
  );
  \tqvp_sohaib_npu.macarray  macarray (
    .\port$0$16 (data_in),
    .\port$31$0 (\$23 )
  );
  \tqvp_sohaib_npu.scaler  scaler (
    .clk(clk),
    .req__payload(req__payload),
    .req__valid(req__valid),
    .resp__payload(resp__payload),
    .resp__valid(resp__valid),
    .rst(rst)
  );
  always @* begin
    if (\$auto$verilog_backend.cc:2373:dump_module$1 ) begin end
    \$19  = shamts;
    if (\$2 ) begin
      \$19  = data_in[4:0];
    end
    if (rst) begin
      \$19  = 5'h00;
    end
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2373:dump_module$1 ) begin end
    \$20  = qmuls;
    if (\$2 ) begin
    end else if (\$4 ) begin
      \$20  = data_in[14:0];
    end
    if (rst) begin
      \$20  = 15'h0000;
    end
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2373:dump_module$1 ) begin end
    \$21  = relu;
    if (\$2 ) begin
    end else if (\$4 ) begin
    end else if (\$6 ) begin
      \$21  = data_in[0];
    end
    if (rst) begin
      \$21  = 1'h0;
    end
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2373:dump_module$1 ) begin end
    \$22  = out_zp;
    if (\$2 ) begin
    end else if (\$4 ) begin
    end else if (\$6 ) begin
      \$22  = data_in[4:1];
    end
    if (rst) begin
      \$22  = 4'h0;
    end
  end
  assign a = data_in[15:0];
  assign w = data_in[31:16];
  assign init__payload = data_in[15:0];
  assign acc__payload = { \$23 [11], \$23 [11], \$23 [11], \$23 [11], \$23  };
  assign d = { \$23 [11], \$23 [11], \$23 [11], \$23 [11], \$23  };
  assign uo_out = 8'h00;
  assign data_out = { 16'h0000, \$16  };
  assign user_interrupt = 1'h0;
  assign \shamts[0]  = shamts;
  assign \qmuls[0]  = qmuls;
  assign \a[0]  = data_in[3:0];
  assign \a[1]  = data_in[7:4];
  assign \a[2]  = data_in[11:8];
  assign \a[3]  = data_in[15:12];
  assign \w[0]  = data_in[19:16];
  assign \w[0][0]  = data_in[19:16];
  assign \w[1]  = data_in[23:20];
  assign \w[1][0]  = data_in[23:20];
  assign \w[2]  = data_in[27:24];
  assign \w[2][0]  = data_in[27:24];
  assign \w[3]  = data_in[31:28];
  assign \w[3][0]  = data_in[31:28];
  assign \init__payload.data  = data_in[15:0];
  assign \init__payload.data[0]  = data_in[15:0];
  assign \acc__payload.data  = { \$23 [11], \$23 [11], \$23 [11], \$23 [11], \$23  };
  assign \acc__payload.data[0]  = { \$23 [11], \$23 [11], \$23 [11], \$23 [11], \$23  };
  assign \d[0]  = { \$23 [11], \$23 [11], \$23 [11], \$23 [11], \$23  };
  assign \req__payload.a  = req__payload[15:0];
  assign \req__payload.a[0]  = req__payload[15:0];
  assign \req__payload.b  = req__payload[30:16];
  assign \req__payload.b[0]  = req__payload[30:16];
  assign \req__payload.zp  = req__payload[34:31];
  assign \req__payload.shamt  = req__payload[39:35];
  assign \req__payload.shamt[0]  = req__payload[39:35];
  assign \read__data[0]  = read__data;
  assign \resp__payload[0]  = resp__payload;
  assign req__payload[34:31] = out_zp;
  assign req__payload[30:16] = qmuls;
  assign req__payload[15:0] = \$11 ;
  assign req__payload[39:35] = shamts;
endmodule

module \tqvp_sohaib_npu.acc_regs (clk, rst, init__valid, acc__valid, \port$31$0 , read__data, init__payload);
  reg \$auto$verilog_backend.cc:2373:dump_module$2  = 0;
  wire \$1 ;
  wire [4:0] \$11 ;
  wire \$2 ;
  wire [15:0] \$3 ;
  wire [16:0] \$4 ;
  reg [15:0] \$5 ;
  wire [4:0] \$6 ;
  wire [15:0] acc__payload;
  wire [-1:0] \acc__payload.addr ;
  wire [15:0] \acc__payload.data ;
  wire [15:0] \acc__payload.data[0] ;
  input acc__valid;
  wire acc__valid;
  input clk;
  wire clk;
  input [15:0] init__payload;
  wire [15:0] init__payload;
  wire [-1:0] \init__payload.addr ;
  wire [15:0] \init__payload.data ;
  wire [15:0] \init__payload.data[0] ;
  input init__valid;
  wire init__valid;
  input [11:0] \port$31$0 ;
  wire [11:0] \port$31$0 ;
  wire [-1:0] read__addr;
  output [15:0] read__data;
  wire [15:0] read__data;
  wire [15:0] \read__data[0] ;
  reg [15:0] regs = 16'h0000;
  wire [15:0] \regs[0] ;
  wire [15:0] \regs[0][0] ;
  input rst;
  wire rst;
  assign \$4  = $signed(\$3 ) + $signed(\port$31$0 );
  always @(posedge clk)
    regs <= \$5 ;
  always @* begin
    if (\$auto$verilog_backend.cc:2373:dump_module$2 ) begin end
    \$5  = regs;
    if (\$1 ) begin
      \$5  = init__payload;
    end else if (\$2 ) begin
      \$5  = \$4 [15:0];
    end
    if (rst) begin
      \$5  = 16'h0000;
    end
  end
  assign acc__payload = { \port$31$0 [11], \port$31$0 [11], \port$31$0 [11], \port$31$0 [11], \port$31$0  };
  assign \read__data[0]  = read__data;
  assign \regs[0]  = regs;
  assign \regs[0][0]  = regs;
  assign \init__payload.data  = init__payload;
  assign \init__payload.data[0]  = init__payload;
  assign \acc__payload.data  = { \port$31$0 [11], \port$31$0 [11], \port$31$0 [11], \port$31$0 [11], \port$31$0  };
  assign \acc__payload.data[0]  = { \port$31$0 [11], \port$31$0 [11], \port$31$0 [11], \port$31$0 [11], \port$31$0  };
  assign \$6  = 5'h00;
  assign read__data = regs;
  assign \$1  = init__valid;
  assign \$2  = acc__valid;
  assign \$11  = 5'h00;
  assign \$3  = regs;
endmodule

module \tqvp_sohaib_npu.macarray (\port$31$0 , \port$0$16 );
  wire [7:0] \$1 ;
  wire [8:0] \$2 ;
  wire [7:0] \$3 ;
  wire [9:0] \$4 ;
  wire [7:0] \$5 ;
  wire [10:0] \$6 ;
  wire [7:0] \$7 ;
  wire [11:0] \$8 ;
  wire [15:0] a;
  wire [3:0] \a[0] ;
  wire [3:0] \a[1] ;
  wire [3:0] \a[2] ;
  wire [3:0] \a[3] ;
  wire [15:0] d;
  wire [15:0] \d[0] ;
  input [31:0] \port$0$16 ;
  wire [31:0] \port$0$16 ;
  output [11:0] \port$31$0 ;
  wire [11:0] \port$31$0 ;
  wire [15:0] w;
  wire [3:0] \w[0] ;
  wire [3:0] \w[0][0] ;
  wire [3:0] \w[1] ;
  wire [3:0] \w[1][0] ;
  wire [3:0] \w[2] ;
  wire [3:0] \w[2][0] ;
  wire [3:0] \w[3] ;
  wire [3:0] \w[3][0] ;
  assign \$2  = $signed(1'h0) + $signed(\$1 );
  assign \$3  = $signed(\port$0$16 [7:4]) * $signed(\port$0$16 [23:20]);
  assign \$4  = $signed(\$2 ) + $signed(\$3 );
  assign \$5  = $signed(\port$0$16 [11:8]) * $signed(\port$0$16 [27:24]);
  assign \$6  = $signed(\$4 ) + $signed(\$5 );
  assign \$7  = $signed(\port$0$16 [15:12]) * $signed(\port$0$16 [31:28]);
  assign \$8  = $signed(\$6 ) + $signed(\$7 );
  assign \$1  = $signed(\port$0$16 [3:0]) * $signed(\port$0$16 [19:16]);
  assign d = { \$8 [11], \$8 [11], \$8 [11], \$8 [11], \$8  };
  assign a = \port$0$16 [15:0];
  assign w = \port$0$16 [31:16];
  assign \port$31$0  = \$8 ;
  assign \d[0]  = { \$8 [11], \$8 [11], \$8 [11], \$8 [11], \$8  };
  assign \a[0]  = \port$0$16 [3:0];
  assign \a[1]  = \port$0$16 [7:4];
  assign \a[2]  = \port$0$16 [11:8];
  assign \a[3]  = \port$0$16 [15:12];
  assign \w[0]  = \port$0$16 [19:16];
  assign \w[0][0]  = \port$0$16 [19:16];
  assign \w[1]  = \port$0$16 [23:20];
  assign \w[1][0]  = \port$0$16 [23:20];
  assign \w[2]  = \port$0$16 [27:24];
  assign \w[2][0]  = \port$0$16 [27:24];
  assign \w[3]  = \port$0$16 [31:28];
  assign \w[3][0]  = \port$0$16 [31:28];
endmodule

module \tqvp_sohaib_npu.scaler (rst, req__valid, resp__payload, req__payload, resp__valid, clk);
  reg \$auto$verilog_backend.cc:2373:dump_module$3  = 0;
  wire [30:0] \$1 ;
  wire [31:0] \$10 ;
  wire \$11 ;
  wire \$12 ;
  wire \$13 ;
  wire [3:0] \$14 ;
  wire \$15 ;
  wire \$16 ;
  wire [2:0] \$17 ;
  wire [18:0] \$18 ;
  wire [33:0] \$19 ;
  wire [31:0] \$2 ;
  wire [34:0] \$20 ;
  reg \$21 ;
  reg [2:0] \$22 ;
  reg [30:0] \$23 ;
  wire \$3 ;
  wire [30:0] \$4 ;
  wire [31:0] \$5 ;
  wire \$6 ;
  wire [30:0] \$7 ;
  wire [31:0] \$8 ;
  wire [31:0] \$9 ;
  reg [30:0] accs = 31'h00000000;
  wire [30:0] \accs[0] ;
  input clk;
  wire clk;
  reg [2:0] done_counter = 3'h0;
  reg [3:0] pshift;
  input [39:0] req__payload;
  wire [39:0] req__payload;
  wire [15:0] \req__payload.a ;
  wire [15:0] \req__payload.a[0] ;
  wire [14:0] \req__payload.b ;
  wire [14:0] \req__payload.b[0] ;
  wire [4:0] \req__payload.shamt ;
  wire [4:0] \req__payload.shamt[0] ;
  wire [3:0] \req__payload.zp ;
  wire req__ready;
  input req__valid;
  wire req__valid;
  output [3:0] resp__payload;
  wire [3:0] resp__payload;
  wire [3:0] \resp__payload[0] ;
  output resp__valid;
  reg resp__valid = 1'h0;
  input rst;
  wire rst;
  assign req__ready = ! done_counter;
  assign \$1  = $signed(accs) >>> req__payload[39:35];
  assign \$2  = $signed(\$1 ) + $signed(req__payload[34:31]);
  assign \$3  = $signed(\$2 ) < $signed(4'h8);
  assign \$4  = $signed(accs) >>> req__payload[39:35];
  assign \$5  = $signed(\$4 ) + $signed(req__payload[34:31]);
  assign \$6  = $signed(\$5 ) > $signed(4'h7);
  assign \$7  = $signed(accs) >>> req__payload[39:35];
  assign \$8  = $signed(\$7 ) + $signed(req__payload[34:31]);
  assign \$9  = \$6  ? 32'd7 : \$8 ;
  assign \$10  = \$3  ? -32'd8 : \$9 ;
  assign \$11  = done_counter == 1'h1;
  assign \$12  = req__valid & req__ready;
  assign \$13  = ~ req__ready;
  assign \$14  = done_counter - 1'h1;
  assign \$15  = req__valid & req__ready;
  assign \$16  = ~ req__ready;
  assign \$17  = req__payload[30:16] >> pshift;
  assign \$18  = $signed({ 1'h0, \$17  }) * $signed(req__payload[15:0]);
  assign \$19  = $signed(\$18 ) << pshift;
  assign \$20  = $signed(accs) + $signed(\$19 );
  always @(posedge clk)
    resp__valid <= \$21 ;
  always @(posedge clk)
    done_counter <= \$22 ;
  always @(posedge clk)
    accs <= \$23 ;
  always @* begin
    if (\$auto$verilog_backend.cc:2373:dump_module$3 ) begin end
    pshift = 4'h0;
    casez (done_counter)
      3'h1:
          pshift = 4'hc;
      3'h2:
          pshift = 4'h9;
      3'h3:
          pshift = 4'h6;
      3'h4:
          pshift = 4'h3;
      3'h5:
          pshift = 4'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2373:dump_module$3 ) begin end
    \$21  = \$11 ;
    if (rst) begin
      \$21  = 1'h0;
    end
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2373:dump_module$3 ) begin end
    \$22  = done_counter;
    if (\$12 ) begin
      \$22  = 3'h5;
    end else if (\$13 ) begin
      \$22  = \$14 [2:0];
    end
    if (rst) begin
      \$22  = 3'h0;
    end
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2373:dump_module$3 ) begin end
    \$23  = accs;
    if (\$15 ) begin
      \$23  = 31'h00000000;
    end else if (\$16 ) begin
      \$23  = \$20 [30:0];
    end
    if (rst) begin
      \$23  = 31'h00000000;
    end
  end
  assign resp__payload = \$10 [3:0];
  assign \resp__payload[0]  = \$10 [3:0];
  assign \accs[0]  = accs;
  assign \req__payload.a  = req__payload[15:0];
  assign \req__payload.a[0]  = req__payload[15:0];
  assign \req__payload.b  = req__payload[30:16];
  assign \req__payload.b[0]  = req__payload[30:16];
  assign \req__payload.zp  = req__payload[34:31];
  assign \req__payload.shamt  = req__payload[39:35];
  assign \req__payload.shamt[0]  = req__payload[39:35];
endmodule
