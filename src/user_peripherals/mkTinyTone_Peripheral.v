//
// Generated by Bluespec Compiler, version 2025.01.1-12-g9e7cf481 (build 9e7cf481)
//
// On Sat Aug 30 12:00:55 IST 2025
//
//
// Ports:
// Name                         I/O  size props
// RDY_write_data                 O     1 const
// read_data                      O    32
// RDY_read_data                  O     1 const
// data_ready                     O     1 reg
// RDY_data_ready                 O     1 const
// user_interrupt                 O     1 const
// RDY_user_interrupt             O     1 const
// uo_out                         O     8
// RDY_uo_out                     O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// write_data_address             I     6
// write_data_data                I    32 reg
// write_data_data_write_n        I     2
// read_data_address              I     6
// read_data_data_read_n          I     2
// uo_out_ui_in                   I     8 unused
// EN_write_data                  I     1
// EN_read_data                   I     1 unused
//
// Combinational paths from inputs to outputs:
//   (read_data_address, read_data_data_read_n) -> read_data
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTinyTone_Peripheral(CLK,
			     RST_N,

			     write_data_address,
			     write_data_data,
			     write_data_data_write_n,
			     EN_write_data,
			     RDY_write_data,

			     read_data_address,
			     read_data_data_read_n,
			     EN_read_data,
			     read_data,
			     RDY_read_data,

			     data_ready,
			     RDY_data_ready,

			     user_interrupt,
			     RDY_user_interrupt,

			     uo_out_ui_in,
			     uo_out,
			     RDY_uo_out);
  input  CLK;
  input  RST_N;

  // action method write_data
  input  [5 : 0] write_data_address;
  input  [31 : 0] write_data_data;
  input  [1 : 0] write_data_data_write_n;
  input  EN_write_data;
  output RDY_write_data;

  // actionvalue method read_data
  input  [5 : 0] read_data_address;
  input  [1 : 0] read_data_data_read_n;
  input  EN_read_data;
  output [31 : 0] read_data;
  output RDY_read_data;

  // value method data_ready
  output data_ready;
  output RDY_data_ready;

  // value method user_interrupt
  output user_interrupt;
  output RDY_user_interrupt;

  // value method uo_out
  input  [7 : 0] uo_out_ui_in;
  output [7 : 0] uo_out;
  output RDY_uo_out;

  // signals for module outputs
  wire [31 : 0] read_data;
  wire [7 : 0] uo_out;
  wire RDY_data_ready,
       RDY_read_data,
       RDY_uo_out,
       RDY_user_interrupt,
       RDY_write_data,
       data_ready,
       user_interrupt;

  // register controlReg
  reg [31 : 0] controlReg;
  wire [31 : 0] controlReg$D_IN;
  wire controlReg$EN;

  // register dataReady
  reg dataReady;
  wire dataReady$D_IN, dataReady$EN;

  // register freqReg
  reg [31 : 0] freqReg;
  wire [31 : 0] freqReg$D_IN;
  wire freqReg$EN;

  // register prevEnable
  reg prevEnable;
  wire prevEnable$D_IN, prevEnable$EN;

  // register prevFreq
  reg [31 : 0] prevFreq;
  wire [31 : 0] prevFreq$D_IN;
  wire prevFreq$EN;

  // register toneGen_counter
  reg [31 : 0] toneGen_counter;
  wire [31 : 0] toneGen_counter$D_IN;
  wire toneGen_counter$EN;

  // register toneGen_enable
  reg toneGen_enable;
  wire toneGen_enable$D_IN, toneGen_enable$EN;

  // register toneGen_freq
  reg [31 : 0] toneGen_freq;
  wire [31 : 0] toneGen_freq$D_IN;
  wire toneGen_freq$EN;

  // register toneGen_pwm
  reg toneGen_pwm;
  wire toneGen_pwm$D_IN, toneGen_pwm$EN;

  // register versionReg
  reg [31 : 0] versionReg;
  wire [31 : 0] versionReg$D_IN;
  wire versionReg$EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_toneGen_count,
       CAN_FIRE_RL_updateToneGenEnable,
       CAN_FIRE_RL_updateToneGenFreq,
       CAN_FIRE_read_data,
       CAN_FIRE_write_data,
       WILL_FIRE_RL_toneGen_count,
       WILL_FIRE_RL_updateToneGenEnable,
       WILL_FIRE_RL_updateToneGenFreq,
       WILL_FIRE_read_data,
       WILL_FIRE_write_data;

  // remaining internal signals
  reg [31 : 0] IF_read_data_address_BITS_5_TO_2_6_EQ_0_7_THEN_ETC___d36;
  wire [31 : 0] result___1__h847;
  wire toneGen_counter_ULT_toneGen_freq___d4;

  // action method write_data
  assign RDY_write_data = 1'd1 ;
  assign CAN_FIRE_write_data = 1'd1 ;
  assign WILL_FIRE_write_data = EN_write_data ;

  // actionvalue method read_data
  assign read_data =
	     (read_data_data_read_n == 2'd0) ?
	       IF_read_data_address_BITS_5_TO_2_6_EQ_0_7_THEN_ETC___d36 :
	       32'd0 ;
  assign RDY_read_data = 1'd1 ;
  assign CAN_FIRE_read_data = 1'd1 ;
  assign WILL_FIRE_read_data = EN_read_data ;

  // value method data_ready
  assign data_ready = dataReady ;
  assign RDY_data_ready = 1'd1 ;

  // value method user_interrupt
  assign user_interrupt = 1'd0 ;
  assign RDY_user_interrupt = 1'd1 ;

  // value method uo_out
  assign uo_out = toneGen_pwm ? 8'd1 : 8'd0 ;
  assign RDY_uo_out = 1'd1 ;

  // rule RL_toneGen_count
  assign CAN_FIRE_RL_toneGen_count = toneGen_enable ;
  assign WILL_FIRE_RL_toneGen_count = toneGen_enable ;

  // rule RL_updateToneGenEnable
  assign CAN_FIRE_RL_updateToneGenEnable = prevEnable != controlReg[0] ;
  assign WILL_FIRE_RL_updateToneGenEnable = CAN_FIRE_RL_updateToneGenEnable ;

  // rule RL_updateToneGenFreq
  assign CAN_FIRE_RL_updateToneGenFreq = prevFreq != freqReg ;
  assign WILL_FIRE_RL_updateToneGenFreq = CAN_FIRE_RL_updateToneGenFreq ;

  // register controlReg
  assign controlReg$D_IN = write_data_data ;
  assign controlReg$EN =
	     EN_write_data && write_data_data_write_n == 2'd0 &&
	     write_data_address[5:2] == 4'd0 ;

  // register dataReady
  assign dataReady$D_IN = 1'b0 ;
  assign dataReady$EN = 1'b0 ;

  // register freqReg
  assign freqReg$D_IN = write_data_data ;
  assign freqReg$EN =
	     EN_write_data && write_data_data_write_n == 2'd0 &&
	     write_data_address[5:2] == 4'd1 ;

  // register prevEnable
  assign prevEnable$D_IN = controlReg[0] ;
  assign prevEnable$EN = CAN_FIRE_RL_updateToneGenEnable ;

  // register prevFreq
  assign prevFreq$D_IN = freqReg ;
  assign prevFreq$EN = CAN_FIRE_RL_updateToneGenFreq ;

  // register toneGen_counter
  assign toneGen_counter$D_IN =
	     toneGen_counter_ULT_toneGen_freq___d4 ?
	       toneGen_counter + 32'd1 :
	       32'd0 ;
  assign toneGen_counter$EN = toneGen_enable ;

  // register toneGen_enable
  assign toneGen_enable$D_IN = controlReg[0] ;
  assign toneGen_enable$EN = CAN_FIRE_RL_updateToneGenEnable ;

  // register toneGen_freq
  assign toneGen_freq$D_IN = freqReg ;
  assign toneGen_freq$EN = CAN_FIRE_RL_updateToneGenFreq ;

  // register toneGen_pwm
  assign toneGen_pwm$D_IN = !toneGen_pwm ;
  assign toneGen_pwm$EN =
	     toneGen_enable && !toneGen_counter_ULT_toneGen_freq___d4 ;

  // register versionReg
  assign versionReg$D_IN = 32'h0 ;
  assign versionReg$EN = 1'b0 ;

  // remaining internal signals
  assign result___1__h847 = { 31'd0, toneGen_pwm } ;
  assign toneGen_counter_ULT_toneGen_freq___d4 =
	     toneGen_counter < toneGen_freq ;
  always@(read_data_address or
	  controlReg or freqReg or result___1__h847 or versionReg)
  begin
    case (read_data_address[5:2])
      4'd0:
	  IF_read_data_address_BITS_5_TO_2_6_EQ_0_7_THEN_ETC___d36 =
	      controlReg;
      4'd1:
	  IF_read_data_address_BITS_5_TO_2_6_EQ_0_7_THEN_ETC___d36 = freqReg;
      4'd2:
	  IF_read_data_address_BITS_5_TO_2_6_EQ_0_7_THEN_ETC___d36 =
	      result___1__h847;
      4'd3:
	  IF_read_data_address_BITS_5_TO_2_6_EQ_0_7_THEN_ETC___d36 =
	      versionReg;
      default: IF_read_data_address_BITS_5_TO_2_6_EQ_0_7_THEN_ETC___d36 =
		   32'd0;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        controlReg <= `BSV_ASSIGNMENT_DELAY 32'd0;
	dataReady <= `BSV_ASSIGNMENT_DELAY 1'd1;
	freqReg <= `BSV_ASSIGNMENT_DELAY 32'd1000;
	prevEnable <= `BSV_ASSIGNMENT_DELAY 1'd0;
	prevFreq <= `BSV_ASSIGNMENT_DELAY 32'd1000;
	toneGen_counter <= `BSV_ASSIGNMENT_DELAY 32'd0;
	toneGen_enable <= `BSV_ASSIGNMENT_DELAY 1'd0;
	toneGen_freq <= `BSV_ASSIGNMENT_DELAY 32'd0;
	toneGen_pwm <= `BSV_ASSIGNMENT_DELAY 1'd0;
	versionReg <= `BSV_ASSIGNMENT_DELAY 32'h00010000;
      end
    else
      begin
        if (controlReg$EN)
	  controlReg <= `BSV_ASSIGNMENT_DELAY controlReg$D_IN;
	if (dataReady$EN) dataReady <= `BSV_ASSIGNMENT_DELAY dataReady$D_IN;
	if (freqReg$EN) freqReg <= `BSV_ASSIGNMENT_DELAY freqReg$D_IN;
	if (prevEnable$EN)
	  prevEnable <= `BSV_ASSIGNMENT_DELAY prevEnable$D_IN;
	if (prevFreq$EN) prevFreq <= `BSV_ASSIGNMENT_DELAY prevFreq$D_IN;
	if (toneGen_counter$EN)
	  toneGen_counter <= `BSV_ASSIGNMENT_DELAY toneGen_counter$D_IN;
	if (toneGen_enable$EN)
	  toneGen_enable <= `BSV_ASSIGNMENT_DELAY toneGen_enable$D_IN;
	if (toneGen_freq$EN)
	  toneGen_freq <= `BSV_ASSIGNMENT_DELAY toneGen_freq$D_IN;
	if (toneGen_pwm$EN)
	  toneGen_pwm <= `BSV_ASSIGNMENT_DELAY toneGen_pwm$D_IN;
	if (versionReg$EN)
	  versionReg <= `BSV_ASSIGNMENT_DELAY versionReg$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    controlReg = 32'hAAAAAAAA;
    dataReady = 1'h0;
    freqReg = 32'hAAAAAAAA;
    prevEnable = 1'h0;
    prevFreq = 32'hAAAAAAAA;
    toneGen_counter = 32'hAAAAAAAA;
    toneGen_enable = 1'h0;
    toneGen_freq = 32'hAAAAAAAA;
    toneGen_pwm = 1'h0;
    versionReg = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkTinyTone_Peripheral

